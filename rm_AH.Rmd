---
title: "rm_AH"
output: html_document
date: "2022-11-23"
---


```{r}
#may not need all these libraries
library(dplyr)
library(sf)
library(tidyverse)
library(ggplot2)
library(leaflet)
library(leaflet.extras)
library(leaflet.extras2)
library(htmltools)
library(htmlwidgets)
library(splitstackshape)
library(RColorBrewer)
library(viridisLite)
```


```{r}
sales <- read_csv("filtered_sales.csv")
LIHTC <- read_csv("LIHTC.csv")
properties <- read_csv("property_details.csv")
barnes <- read_csv("barnes.csv")
assessments <- read_csv("assessments.csv")
```
```{r}
assessments
sales
LIHTC
properties
barnes
```
```{r}
sales <- sales[!duplicated(sales), ]
sales
```


```{r}
LIHTC <- st_as_sf(LIHTC, coords =c("LONGITUDE","LATITUDE"), crs =4326) #convert to sf object
```


```{r}
nash <- st_read("Davidson.geojson") #this is Davidson county border for plotting
```


```{r}
properties$centroid <- gsub("[()]", "", properties$centroid) #remove () from coordinates
properties
```

```{r}
properties <- cSplit(properties, "centroid", ",") #split coordinates into lat and lon
names(properties)[names(properties) == 'centroid_1'] <- 'lon'
names(properties)[names(properties) == 'centroid_2'] <- 'lat'
properties
```

```{r}
properties <- st_as_sf(properties, coords =c("lon","lat"), crs =4326) #convert to sf
```
```{r}
properties
```

```{r}
# simple map of locations within Davidson County
nash %>% 
leaflet()  %>% 
    addProviderTiles("CartoDB.Positron")  %>% 
    addPolygons(color ="white", opacity=5) %>%
    addCircleMarkers(data = LIHTC, radius = 1 , popup = LIHTC$PROJECT, color="red") %>%
    setView(lat = 36.1627, lng = -86.7816, zoom = 11)
```

```{r}
lihtc_drop <- LIHTC[-c(1, 2, 3, 4, 5), ]
```


```{r}
#1. Using the sf library, find the closest development to each home.
nearest <- st_nearest_feature(properties, lihtc_drop) #find nearest properties https://gis.stackexchange.com/questions/349955/getting-a-new-column-with-distance-to-the-nearest-feature-in-r
```


```{r}
# 2. Calculate the distance from each home its closest development.
dist_miles = st_distance(properties, lihtc_drop[nearest,], by_element=TRUE) %>% 
units::set_units(mi) #without this, the default is in meters
dist_miles
```
```{r}
p_join = cbind(properties, st_drop_geometry(lihtc_drop)[nearest,])
p_join
```
```{r}
p_join$distance <- dist_miles
p_join
```


```{r}
p_join$distance <- gsub("[mi]", "", p_join$distance) #remove mi
p_join
```



```{r}
# 3. Filter the homes down to those that are within one mile of an affordable housing development.
one_mile <- p_join %>% #filter down to homes within 1 mile
  filter(p_join$distance<1)
```

```{r}
one_mile
```
```{r}
# map of properties within one mile 
nash %>% 
leaflet()  %>% 
    addProviderTiles("Stamen.TonerHybrid")  %>% 
    addPolygons(color ="grey", opacity=1) %>%
    addCircleMarkers(data = one_mile, radius = 1 , popup = one_mile$PROJECT, 
                     color="blue", opacity=0.1, clusterOptions = markerClusterOptions()) %>%
    addCircleMarkers(data = lihtc_drop, radius = 4 , popup = lihtc_drop$PROJECT, color="red") %>%
    setView(lat = 36.1627, lng = -86.7816, zoom = 11)
```
```{r}
one_mile <- merge(one_mile, sales, by.x = "apn", by.y = "apn")
one_mile
```

# testing out case_when function
```{r}
one_mile<- one_mile%>% 
       mutate(half_mile = case_when(distance < 0.5 ~ "less than",
                                        TRUE ~ "more than"))
one_mile
```

```{r}
table(one_mile$half_mile)
```

```{r}
one_mile$ownerdate <- format(as.Date(one_mile$ownerdate, format="%Y/%m/%d"),"%Y")
one_mile
```

```{r}
one_mile$ownerdate <- as.numeric(as.character(one_mile$ownerdate))
```


4. For each remaining home, calculate a new column called "group", which is defined according to the following rules. Hint: Use the case_when function to do this.

```{r}
one_mile <- one_mile %>% 
       mutate(group = case_when(half_mile == "less than" & ownerdate<=(YR_PIS - 2) & ownerdate>=(YR_PIS - 5) ~ "pre",
                                half_mile == "less than" & ownerdate<=YR_PIS  & ownerdate>=(YR_PIS - 2) ~ "mid",
                                half_mile == "less than" & ownerdate>YR_PIS ~ "post",
                                half_mile == "more than" & ownerdate>=(YR_PIS - 5)  ~ "outside",
                                TRUE ~ "other"))
one_mile
```
```{r}
table(one_mile$group)
```

```{r}
out <- one_mile %>% 
  filter(one_mile$group =="outside")
out
```



5. Filter out all rows whose group is "other".

```{r}
one_mile <- one_mile[!grepl("other", one_mile$group),]
one_mile
```

7. Create a column "Tpost" that, for homes in the "post" group gives the number of years that the sale occurred after the housing development was placed in service.

```{r}
one_mile <- one_mile %>%
  mutate(Tpost = case_when(
  group=="post" ~ ownerdate-YR_PIS
))
```

8. Create a column named "age" which gives the age of the home at the time of sale.
```{r}
one_mile <- one_mile %>%
  mutate(age = (ownerdate - year_built))
one_mile
```
9. Filter down to only sales that took place within the five years before or after the associated development was placed in service.
```{r}
filtered_sales_lm <- one_mile %>% 
  filter((ownerdate-YR_PIS) <=5 & (YR_PIS-ownerdate) <=5)
filtered_sales_lm
```

```{r}
filtered_sales_lm2 <- one_mile %>% 
  filter(abs(YR_PIS-ownerdate) <=5) 
filtered_sales_lm2
```


Then build a linear model with target variable the sales amount using the following features:
square_footage
age of home at time of sale
group
year
tract
```{r}
lm_model <- lm(amount ~ square_footage + 
                 age + 
                 group + 
                 ownerdate + 
                 factor(tract),
                 data = filtered_sales_lm)
summary(lm_model)
```
How can you interpret the coefficients of this model?

10. Now, try a model with target being the log of the sale price.

```{r}
lm_model_log <- lm(log(amount) ~ square_footage + 
                 age + 
                 group + 
                 ownerdate + 
                 factor(tract),
                 data = filtered_sales_lm)
summary(lm_model_log)
```

```{r}
ggplot(filtered_sales_lm, aes(log(square_footage),log(amount))) +
  geom_point(alpha=0.5, na.rm=TRUE)
```


